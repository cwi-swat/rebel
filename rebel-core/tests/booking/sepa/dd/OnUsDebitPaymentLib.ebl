module booking.sepa.dd.OnUsDebitPaymentLib

import DateLib
import account.payment.CurrentAccount
import account.payment.BusinessCurrentAccount
import account.process.SepaDirectDebitWashAccount

event create(id: Integer, debtor: IBAN, creditor: IBAN, amount: Money, settlementDate: Date) {
	preconditions {
		globalCredit > EUR 0.00;
		
		// Only customers with a business account can create a Sepa DD booking
		initialized BusinessCurrentAccount[creditor];
		initialized Customer[debtor];
	}
	postconditions {
		new this.id == id;
		new this.debtor == debtor;
		new this.creditor == creditor;
		new this.amount == amount;
		new this.customerId == customerId;
		new this.settlementDate == nextTarget2Day(settlementDate);
		// Creation date is already set to the (probably) new rules regarding creationDate D-1 to be effected in august 2016
		new this.creationDate == previousTarget2Day(new this.settlementDate);
	}
}

event book() {
	preconditions {
		this.settlementDate == now;
		//now <= 6:00;
		// if customer is 'onder curatele' it should not be possible to book
		//not Customer[this.debtor] in {curantele}; 
	}
	sync {
		BusinessCurrentAccount[this.debtor].withdraw(this.amount);
		SepaDirectDebitWashAccount[1].deposit(this.amount);
	}
}

event forceBooking() {
	sync {
		BusinessCurrentAccount[this.debtor].forcedWithdraw(this.amount);
		//RevolvingWashAccount.deposit(this.amount);
	}
}

event bookAfterRevolve() {
	preconditions {
		//now <= 6:00
		this.settlementDate >= now && this.settlementDate <= now + next3Target2Days(this.settlementDate);
	}
	sync {
		BusinessCurrentAccount[this.debtor].withdraw(this.amount);
		//RevolvingWashAccount.deposit(this.amount);
	}
}

event revolve() {
	preconditions {
		this.settlementDate == now;
	}
	sync {
		// not enough balance on account
		not CurrentAccount[this.debtor].withdraw(this.amount);
		SepaDirectDebitWashAccount[1].deposit(this.amount);
		//RevolvingWashAccount.withdraw(this.amount);
	}
}

event return() {
	preconditions {
		after3Target2Days(this.settlementDate);	
	}
	sync {
		BusinessCurrentAccount[this.creditor].forcedWithdraw(this.amount);
		//RevolvingWashAccount.deposit(this.amount);
	}
}

event denied() {
	preconditions {
		within3Target2Days(this.settlementDate);	
	}
	sync {
		BusinessCurrentAccount[this.creditor].forcedWithdraw(this.amount);
		//RevolvingWashAccount.deposit(this.amount);
	}
}

event needsAdvice() {
	preconditions {
		Customer[this.debtor] in {curatele};
	}
}

event revoke() {
	preconditions {
		this.settlementDate > now;
	}
}

//event reject(reason: Integer) {
//	preconditions {
//		this.settlementDate > now;
//		// Reason should be one of the ones mentioned in the Sepa DD Core rulebook (page 88)
//	}
//	sync {
//		BusinessCurrentAccount[this.creditor].forcedWithdraw(this.amount);
//		SepaDirectDebitWashAccount.deposit(this.amount);
//	}
//}

event refundWithin8Weeks() {
	preconditions {
		now >= this.settlementDate;
		within(8 Week, now); 
	}
	sync {
		BusinessCurrentAccount[this.creditor].forcedWithdraw(this.amount);
		CurrentAccount[this.debtor].forcedDeposit(this.amount);	
	}
}

event refundAfter8Weeks() {
	preconditions {
		now >= this.settlementDate;
		between(8 Week, 13 Month, now);
		// unauthorized direct debit, no mandate
		not initialized Mandate[this.creditor]; // key should be this.creditor, this.debtor
	}
	sync {
		BusinessCurrentAccount[this.creditor].forcedWithdraw(this.amount);
		CurrentAccount[this.debtor].forcedDeposit(this.amount);	
	}
}

event reverse() {
	preconditions {
		now >= this.settlementDate;
		beforeTarget2Day(5 Day, this.settlementDate, now);
	}
	sync {
		BusinessCurrentAccount[this.creditor].forcedWithdraw(this.amount);
		CurrentAccount[this.debtor].forcedDeposit(this.amount);	
	}
}

event finalize() {
	preconditions {
		after(13 Month, this.settlementDate);
	}
}
